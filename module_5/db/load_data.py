"""
load_data.py
==============

This module defines the `DataLoader` class to manage reading applicant data from a JSON file
and loading it into a PostgreSQL database.

:class DataLoader: Handles connection, table creation, data loading, and data insertion.
:function run_loader: Executes the full data loading process including table creation and
                      data insertion.
"""
from pathlib import Path
import json
import psycopg
from psycopg import sql
from db.connection import get_db_connection

class DataLoader:
    """
    A class to handle the process of reading applicant data from a JSON file
    and loading it into a PostgreSQL database.

    :ivar connection: Connection object to the PostgreSQL database.
    :vartype connection: psycopg.Connection
    :ivar json_path: File path to the JSON data file.
    :vartype json_path: pathlib.Path
    """

    def __init__(self):
        """
        Initializes the class by setting up a database connection and the path to the JSON file.
        """

        # Create a connection to the PostgreSQL database
        self.connection = get_db_connection()
        # Full path to the JSON data file
        self.json_path = Path(__file__).parent / 'applicant_data.json'

    def load_data(self) -> list[dict] | None:
        """
        Load applicant data from a JSON file.

        :returns: A list of dictionaries representing applicant records, or None on failure.
        :rtype: list[dict] or None
        :raises FileNotFoundError: If the JSON file is not found.
        :raises json.JSONDecodeError: If there is an error decoding the JSON file.
        :raises OSError: If there is an OS-related error reading the file.
        """
        try:
            with open(self.json_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError as e:
            raise FileNotFoundError(f"File not found: {self.json_path}") from e
        except json.JSONDecodeError as e:
            raise json.JSONDecodeError(
                f"JSON decode error in file {self.json_path}: {e.msg}",
                e.doc,
                e.pos,
            )
        except OSError as e:
            raise OSError(f"Error reading file {self.json_path}: {e.strerror}") from e

    def create_table(self) -> None:
        """
        Create the `applicants` table in the PostgreSQL database if it does not already exist.

        :raises psycopg.OperationalError: If an error occurs during table creation.
        """
        create_table_query = sql.SQL("""
                                CREATE TABLE IF NOT EXISTS {table_name} (
                                    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                    program TEXT,
                                    comments TEXT,
                                    date_added DATE,
                                    url TEXT,
                                    status TEXT,
                                    term TEXT,
                                    us_or_international TEXT,
                                    gpa FLOAT,
                                    gre FLOAT,
                                    gre_v FLOAT,
                                    gre_aw FLOAT,
                                    degree TEXT
                                )
                            """).format(
                                table_name=sql.Identifier("applicants")
                            )

        try:
            # Open cursor to perform database operations
            with self.connection.cursor() as cur: # pylint: disable=no-member
                # Execute table creation
                cur.execute(create_table_query)

                # Commit changes
                self.connection.commit() # pylint: disable=no-member

        except psycopg.OperationalError as e:
            # Print error if something goes wrong with table creation
            print(f"The error '{e}' occurred")

    def insert_to_table(self, data: list[dict]):
        """
        Insert applicant records into the database table if it is currently empty.

        :param data: A list of dictionaries, each representing an applicant's record.
        :type data: list[dict]
        :raises psycopg.OperationalError: If an error occurs during insertion.
        """
        count_query = sql.SQL("""
                            SELECT COUNT(*) FROM {table_name} LIMIT {limit}
                        """).format(
                            table_name = sql.Identifier('applicants'),
                            limit = sql.Literal(1)
                        )

        # insert_query = sql.SQL("""
        #                     INSERT INTO {table_name} (
        #                         program, comments, date_added, url, status, term,
        #                         us_or_international, gpa, gre, gre_v, gre_aw, degree
        #                     ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        #                 """).format(
        #                     table_name=sql.Identifier("applicants")
        #                 )

        columns = [
            'program', 'comments', 'date_added', 'url', 'status', 'term',
            'us_or_international', 'gpa', 'gre', 'gre_v', 'gre_aw', 'degree'
        ]

        insert_query = sql.SQL("""
                            INSERT INTO {table_name} ({fields}) VALUES ({placeholders})
                        """).format(
                            table_name = sql.Identifier("applicants"),
                            fields = sql.SQL(", ").join(map(sql.Identifier, columns)),
                            placeholders = sql.SQL(", ").join(sql.Placeholder() for _ in columns)
                        )

        try:
            with self.connection.cursor() as cur: # pylint: disable=no-member
                # Check if table already has rows
                cur.execute(count_query)
                count_rows = cur.fetchone()[0]

                if count_rows > 0:
                    # Table already includes data - close connection
                    self.connection.close()
                    return

                # Prepare values
                values_list = []
                for row in data:
                    values_list.append(tuple(
                            row.get("program"),
                            row.get("comments"),
                            row.get("date_added"),
                            row.get("url"),
                            row.get("status"),
                            row.get("term"),
                            row.get("us_or_international"),
                            row.get("GPA"),
                            row.get("GRE"),
                            row.get("GRE_V"),
                            row.get("GRE_AW"),
                            row.get("degree")
                        ))

                # Batch insert for performance
                cur.executemany(insert_query, values_list)
                self.connection.commit()
                print(f"Inserted {len(values_list)} records into the applicants table.")

        except psycopg.Error as e:
            print(f"Database insertion error: {e}")

        finally:
            # Close connection
            self.connection.close()

    def close_connection(self):
        """
        Close the database connection if it is open.

        :return: None
        :rtype: None
        """
        if self.connection:
            self.connection.close()

def run_loader():
    """
    Run the full data loading process:

    - Create the `applicants` table in the database.
    - Load data from the local JSON file.
    - Insert the loaded data into the database, if the table is empty.
    """

    # Instantiate the DataLoader class
    loader = DataLoader()

    try:
        # Create the applicants table in the database
        loader.create_table()

        # Load applicant data from the JSON file
        applicants_info = loader.load_data()

        # Insert the loaded data into the database table
        loader.insert_to_table(applicants_info)
    finally:
        loader.close_connection()

# Main execution block
if __name__ == "__main__":
    run_loader()
